/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `ReflectionSession` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from '@prisma/client/runtime/client'
import type * as $Enums from '../enums.ts'
import type * as Prisma from '../internal/prismaNamespace.ts'

/**
 * Model ReflectionSession
 *
 */
export type ReflectionSessionModel =
  runtime.Types.Result.DefaultSelection<Prisma.$ReflectionSessionPayload>

export type AggregateReflectionSession = {
  _count: ReflectionSessionCountAggregateOutputType | null
  _avg: ReflectionSessionAvgAggregateOutputType | null
  _sum: ReflectionSessionSumAggregateOutputType | null
  _min: ReflectionSessionMinAggregateOutputType | null
  _max: ReflectionSessionMaxAggregateOutputType | null
}

export type ReflectionSessionAvgAggregateOutputType = {
  recordingAttempt: number | null
  totalUserSpeakingTime: number | null
  maxDuration: number | null
}

export type ReflectionSessionSumAggregateOutputType = {
  recordingAttempt: number | null
  totalUserSpeakingTime: number | null
  maxDuration: number | null
}

export type ReflectionSessionMinAggregateOutputType = {
  id: string | null
  userId: string | null
  date: Date | null
  status: string | null
  recordingAttempt: number | null
  totalUserSpeakingTime: number | null
  maxDuration: number | null
  summaryText: string | null
  pausedAt: Date | null
  completedAt: Date | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type ReflectionSessionMaxAggregateOutputType = {
  id: string | null
  userId: string | null
  date: Date | null
  status: string | null
  recordingAttempt: number | null
  totalUserSpeakingTime: number | null
  maxDuration: number | null
  summaryText: string | null
  pausedAt: Date | null
  completedAt: Date | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type ReflectionSessionCountAggregateOutputType = {
  id: number
  userId: number
  date: number
  status: number
  recordingAttempt: number
  totalUserSpeakingTime: number
  maxDuration: number
  summaryText: number
  pausedAt: number
  completedAt: number
  createdAt: number
  updatedAt: number
  _all: number
}

export type ReflectionSessionAvgAggregateInputType = {
  recordingAttempt?: true
  totalUserSpeakingTime?: true
  maxDuration?: true
}

export type ReflectionSessionSumAggregateInputType = {
  recordingAttempt?: true
  totalUserSpeakingTime?: true
  maxDuration?: true
}

export type ReflectionSessionMinAggregateInputType = {
  id?: true
  userId?: true
  date?: true
  status?: true
  recordingAttempt?: true
  totalUserSpeakingTime?: true
  maxDuration?: true
  summaryText?: true
  pausedAt?: true
  completedAt?: true
  createdAt?: true
  updatedAt?: true
}

export type ReflectionSessionMaxAggregateInputType = {
  id?: true
  userId?: true
  date?: true
  status?: true
  recordingAttempt?: true
  totalUserSpeakingTime?: true
  maxDuration?: true
  summaryText?: true
  pausedAt?: true
  completedAt?: true
  createdAt?: true
  updatedAt?: true
}

export type ReflectionSessionCountAggregateInputType = {
  id?: true
  userId?: true
  date?: true
  status?: true
  recordingAttempt?: true
  totalUserSpeakingTime?: true
  maxDuration?: true
  summaryText?: true
  pausedAt?: true
  completedAt?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type ReflectionSessionAggregateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which ReflectionSession to aggregate.
   */
  where?: Prisma.ReflectionSessionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of ReflectionSessions to fetch.
   */
  orderBy?:
    | Prisma.ReflectionSessionOrderByWithRelationInput
    | Prisma.ReflectionSessionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the start position
   */
  cursor?: Prisma.ReflectionSessionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` ReflectionSessions from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` ReflectionSessions.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Count returned ReflectionSessions
   **/
  _count?: true | ReflectionSessionCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to average
   **/
  _avg?: ReflectionSessionAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to sum
   **/
  _sum?: ReflectionSessionSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the minimum value
   **/
  _min?: ReflectionSessionMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the maximum value
   **/
  _max?: ReflectionSessionMaxAggregateInputType
}

export type GetReflectionSessionAggregateType<
  T extends ReflectionSessionAggregateArgs,
> = {
  [P in keyof T & keyof AggregateReflectionSession]: P extends
    | '_count'
    | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateReflectionSession[P]>
    : Prisma.GetScalarType<T[P], AggregateReflectionSession[P]>
}

export type ReflectionSessionGroupByArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.ReflectionSessionWhereInput
  orderBy?:
    | Prisma.ReflectionSessionOrderByWithAggregationInput
    | Prisma.ReflectionSessionOrderByWithAggregationInput[]
  by:
    | Prisma.ReflectionSessionScalarFieldEnum[]
    | Prisma.ReflectionSessionScalarFieldEnum
  having?: Prisma.ReflectionSessionScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: ReflectionSessionCountAggregateInputType | true
  _avg?: ReflectionSessionAvgAggregateInputType
  _sum?: ReflectionSessionSumAggregateInputType
  _min?: ReflectionSessionMinAggregateInputType
  _max?: ReflectionSessionMaxAggregateInputType
}

export type ReflectionSessionGroupByOutputType = {
  id: string
  userId: string
  date: Date
  status: string
  recordingAttempt: number
  totalUserSpeakingTime: number
  maxDuration: number
  summaryText: string | null
  pausedAt: Date | null
  completedAt: Date | null
  createdAt: Date
  updatedAt: Date
  _count: ReflectionSessionCountAggregateOutputType | null
  _avg: ReflectionSessionAvgAggregateOutputType | null
  _sum: ReflectionSessionSumAggregateOutputType | null
  _min: ReflectionSessionMinAggregateOutputType | null
  _max: ReflectionSessionMaxAggregateOutputType | null
}

type GetReflectionSessionGroupByPayload<
  T extends ReflectionSessionGroupByArgs,
> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<ReflectionSessionGroupByOutputType, T['by']> & {
      [P in keyof T &
        keyof ReflectionSessionGroupByOutputType]: P extends '_count'
        ? T[P] extends boolean
          ? number
          : Prisma.GetScalarType<T[P], ReflectionSessionGroupByOutputType[P]>
        : Prisma.GetScalarType<T[P], ReflectionSessionGroupByOutputType[P]>
    }
  >
>

export type ReflectionSessionWhereInput = {
  AND?:
    | Prisma.ReflectionSessionWhereInput
    | Prisma.ReflectionSessionWhereInput[]
  OR?: Prisma.ReflectionSessionWhereInput[]
  NOT?:
    | Prisma.ReflectionSessionWhereInput
    | Prisma.ReflectionSessionWhereInput[]
  id?: Prisma.StringFilter<'ReflectionSession'> | string
  userId?: Prisma.StringFilter<'ReflectionSession'> | string
  date?: Prisma.DateTimeFilter<'ReflectionSession'> | Date | string
  status?: Prisma.StringFilter<'ReflectionSession'> | string
  recordingAttempt?: Prisma.IntFilter<'ReflectionSession'> | number
  totalUserSpeakingTime?: Prisma.IntFilter<'ReflectionSession'> | number
  maxDuration?: Prisma.IntFilter<'ReflectionSession'> | number
  summaryText?: Prisma.StringNullableFilter<'ReflectionSession'> | string | null
  pausedAt?:
    | Prisma.DateTimeNullableFilter<'ReflectionSession'>
    | Date
    | string
    | null
  completedAt?:
    | Prisma.DateTimeNullableFilter<'ReflectionSession'>
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFilter<'ReflectionSession'> | Date | string
  updatedAt?: Prisma.DateTimeFilter<'ReflectionSession'> | Date | string
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  turns?: Prisma.ReflectionTurnListRelationFilter
  mood?: Prisma.XOR<
    Prisma.ReflectionMoodNullableScalarRelationFilter,
    Prisma.ReflectionMoodWhereInput
  > | null
  topics?: Prisma.ReflectionTopicListRelationFilter
  insights?: Prisma.ReflectionInsightListRelationFilter
  personMentions?: Prisma.PersonMentionListRelationFilter
}

export type ReflectionSessionOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  date?: Prisma.SortOrder
  status?: Prisma.SortOrder
  recordingAttempt?: Prisma.SortOrder
  totalUserSpeakingTime?: Prisma.SortOrder
  maxDuration?: Prisma.SortOrder
  summaryText?: Prisma.SortOrderInput | Prisma.SortOrder
  pausedAt?: Prisma.SortOrderInput | Prisma.SortOrder
  completedAt?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  user?: Prisma.UserOrderByWithRelationInput
  turns?: Prisma.ReflectionTurnOrderByRelationAggregateInput
  mood?: Prisma.ReflectionMoodOrderByWithRelationInput
  topics?: Prisma.ReflectionTopicOrderByRelationAggregateInput
  insights?: Prisma.ReflectionInsightOrderByRelationAggregateInput
  personMentions?: Prisma.PersonMentionOrderByRelationAggregateInput
}

export type ReflectionSessionWhereUniqueInput = Prisma.AtLeast<
  {
    id?: string
    userId_date?: Prisma.ReflectionSessionUserIdDateCompoundUniqueInput
    AND?:
      | Prisma.ReflectionSessionWhereInput
      | Prisma.ReflectionSessionWhereInput[]
    OR?: Prisma.ReflectionSessionWhereInput[]
    NOT?:
      | Prisma.ReflectionSessionWhereInput
      | Prisma.ReflectionSessionWhereInput[]
    userId?: Prisma.StringFilter<'ReflectionSession'> | string
    date?: Prisma.DateTimeFilter<'ReflectionSession'> | Date | string
    status?: Prisma.StringFilter<'ReflectionSession'> | string
    recordingAttempt?: Prisma.IntFilter<'ReflectionSession'> | number
    totalUserSpeakingTime?: Prisma.IntFilter<'ReflectionSession'> | number
    maxDuration?: Prisma.IntFilter<'ReflectionSession'> | number
    summaryText?:
      | Prisma.StringNullableFilter<'ReflectionSession'>
      | string
      | null
    pausedAt?:
      | Prisma.DateTimeNullableFilter<'ReflectionSession'>
      | Date
      | string
      | null
    completedAt?:
      | Prisma.DateTimeNullableFilter<'ReflectionSession'>
      | Date
      | string
      | null
    createdAt?: Prisma.DateTimeFilter<'ReflectionSession'> | Date | string
    updatedAt?: Prisma.DateTimeFilter<'ReflectionSession'> | Date | string
    user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
    turns?: Prisma.ReflectionTurnListRelationFilter
    mood?: Prisma.XOR<
      Prisma.ReflectionMoodNullableScalarRelationFilter,
      Prisma.ReflectionMoodWhereInput
    > | null
    topics?: Prisma.ReflectionTopicListRelationFilter
    insights?: Prisma.ReflectionInsightListRelationFilter
    personMentions?: Prisma.PersonMentionListRelationFilter
  },
  'id' | 'userId_date'
>

export type ReflectionSessionOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  date?: Prisma.SortOrder
  status?: Prisma.SortOrder
  recordingAttempt?: Prisma.SortOrder
  totalUserSpeakingTime?: Prisma.SortOrder
  maxDuration?: Prisma.SortOrder
  summaryText?: Prisma.SortOrderInput | Prisma.SortOrder
  pausedAt?: Prisma.SortOrderInput | Prisma.SortOrder
  completedAt?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.ReflectionSessionCountOrderByAggregateInput
  _avg?: Prisma.ReflectionSessionAvgOrderByAggregateInput
  _max?: Prisma.ReflectionSessionMaxOrderByAggregateInput
  _min?: Prisma.ReflectionSessionMinOrderByAggregateInput
  _sum?: Prisma.ReflectionSessionSumOrderByAggregateInput
}

export type ReflectionSessionScalarWhereWithAggregatesInput = {
  AND?:
    | Prisma.ReflectionSessionScalarWhereWithAggregatesInput
    | Prisma.ReflectionSessionScalarWhereWithAggregatesInput[]
  OR?: Prisma.ReflectionSessionScalarWhereWithAggregatesInput[]
  NOT?:
    | Prisma.ReflectionSessionScalarWhereWithAggregatesInput
    | Prisma.ReflectionSessionScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<'ReflectionSession'> | string
  userId?: Prisma.StringWithAggregatesFilter<'ReflectionSession'> | string
  date?:
    | Prisma.DateTimeWithAggregatesFilter<'ReflectionSession'>
    | Date
    | string
  status?: Prisma.StringWithAggregatesFilter<'ReflectionSession'> | string
  recordingAttempt?:
    | Prisma.IntWithAggregatesFilter<'ReflectionSession'>
    | number
  totalUserSpeakingTime?:
    | Prisma.IntWithAggregatesFilter<'ReflectionSession'>
    | number
  maxDuration?: Prisma.IntWithAggregatesFilter<'ReflectionSession'> | number
  summaryText?:
    | Prisma.StringNullableWithAggregatesFilter<'ReflectionSession'>
    | string
    | null
  pausedAt?:
    | Prisma.DateTimeNullableWithAggregatesFilter<'ReflectionSession'>
    | Date
    | string
    | null
  completedAt?:
    | Prisma.DateTimeNullableWithAggregatesFilter<'ReflectionSession'>
    | Date
    | string
    | null
  createdAt?:
    | Prisma.DateTimeWithAggregatesFilter<'ReflectionSession'>
    | Date
    | string
  updatedAt?:
    | Prisma.DateTimeWithAggregatesFilter<'ReflectionSession'>
    | Date
    | string
}

export type ReflectionSessionCreateInput = {
  id?: string
  date: Date | string
  status?: string
  recordingAttempt?: number
  totalUserSpeakingTime?: number
  maxDuration?: number
  summaryText?: string | null
  pausedAt?: Date | string | null
  completedAt?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutReflectionSessionsInput
  turns?: Prisma.ReflectionTurnCreateNestedManyWithoutSessionInput
  mood?: Prisma.ReflectionMoodCreateNestedOneWithoutSessionInput
  topics?: Prisma.ReflectionTopicCreateNestedManyWithoutSessionInput
  insights?: Prisma.ReflectionInsightCreateNestedManyWithoutSessionInput
  personMentions?: Prisma.PersonMentionCreateNestedManyWithoutSessionInput
}

export type ReflectionSessionUncheckedCreateInput = {
  id?: string
  userId: string
  date: Date | string
  status?: string
  recordingAttempt?: number
  totalUserSpeakingTime?: number
  maxDuration?: number
  summaryText?: string | null
  pausedAt?: Date | string | null
  completedAt?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  turns?: Prisma.ReflectionTurnUncheckedCreateNestedManyWithoutSessionInput
  mood?: Prisma.ReflectionMoodUncheckedCreateNestedOneWithoutSessionInput
  topics?: Prisma.ReflectionTopicUncheckedCreateNestedManyWithoutSessionInput
  insights?: Prisma.ReflectionInsightUncheckedCreateNestedManyWithoutSessionInput
  personMentions?: Prisma.PersonMentionUncheckedCreateNestedManyWithoutSessionInput
}

export type ReflectionSessionUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  recordingAttempt?: Prisma.IntFieldUpdateOperationsInput | number
  totalUserSpeakingTime?: Prisma.IntFieldUpdateOperationsInput | number
  maxDuration?: Prisma.IntFieldUpdateOperationsInput | number
  summaryText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  pausedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  completedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutReflectionSessionsNestedInput
  turns?: Prisma.ReflectionTurnUpdateManyWithoutSessionNestedInput
  mood?: Prisma.ReflectionMoodUpdateOneWithoutSessionNestedInput
  topics?: Prisma.ReflectionTopicUpdateManyWithoutSessionNestedInput
  insights?: Prisma.ReflectionInsightUpdateManyWithoutSessionNestedInput
  personMentions?: Prisma.PersonMentionUpdateManyWithoutSessionNestedInput
}

export type ReflectionSessionUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  recordingAttempt?: Prisma.IntFieldUpdateOperationsInput | number
  totalUserSpeakingTime?: Prisma.IntFieldUpdateOperationsInput | number
  maxDuration?: Prisma.IntFieldUpdateOperationsInput | number
  summaryText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  pausedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  completedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  turns?: Prisma.ReflectionTurnUncheckedUpdateManyWithoutSessionNestedInput
  mood?: Prisma.ReflectionMoodUncheckedUpdateOneWithoutSessionNestedInput
  topics?: Prisma.ReflectionTopicUncheckedUpdateManyWithoutSessionNestedInput
  insights?: Prisma.ReflectionInsightUncheckedUpdateManyWithoutSessionNestedInput
  personMentions?: Prisma.PersonMentionUncheckedUpdateManyWithoutSessionNestedInput
}

export type ReflectionSessionCreateManyInput = {
  id?: string
  userId: string
  date: Date | string
  status?: string
  recordingAttempt?: number
  totalUserSpeakingTime?: number
  maxDuration?: number
  summaryText?: string | null
  pausedAt?: Date | string | null
  completedAt?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type ReflectionSessionUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  recordingAttempt?: Prisma.IntFieldUpdateOperationsInput | number
  totalUserSpeakingTime?: Prisma.IntFieldUpdateOperationsInput | number
  maxDuration?: Prisma.IntFieldUpdateOperationsInput | number
  summaryText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  pausedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  completedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ReflectionSessionUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  recordingAttempt?: Prisma.IntFieldUpdateOperationsInput | number
  totalUserSpeakingTime?: Prisma.IntFieldUpdateOperationsInput | number
  maxDuration?: Prisma.IntFieldUpdateOperationsInput | number
  summaryText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  pausedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  completedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ReflectionSessionListRelationFilter = {
  every?: Prisma.ReflectionSessionWhereInput
  some?: Prisma.ReflectionSessionWhereInput
  none?: Prisma.ReflectionSessionWhereInput
}

export type ReflectionSessionOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type ReflectionSessionUserIdDateCompoundUniqueInput = {
  userId: string
  date: Date | string
}

export type ReflectionSessionCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  date?: Prisma.SortOrder
  status?: Prisma.SortOrder
  recordingAttempt?: Prisma.SortOrder
  totalUserSpeakingTime?: Prisma.SortOrder
  maxDuration?: Prisma.SortOrder
  summaryText?: Prisma.SortOrder
  pausedAt?: Prisma.SortOrder
  completedAt?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type ReflectionSessionAvgOrderByAggregateInput = {
  recordingAttempt?: Prisma.SortOrder
  totalUserSpeakingTime?: Prisma.SortOrder
  maxDuration?: Prisma.SortOrder
}

export type ReflectionSessionMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  date?: Prisma.SortOrder
  status?: Prisma.SortOrder
  recordingAttempt?: Prisma.SortOrder
  totalUserSpeakingTime?: Prisma.SortOrder
  maxDuration?: Prisma.SortOrder
  summaryText?: Prisma.SortOrder
  pausedAt?: Prisma.SortOrder
  completedAt?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type ReflectionSessionMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  date?: Prisma.SortOrder
  status?: Prisma.SortOrder
  recordingAttempt?: Prisma.SortOrder
  totalUserSpeakingTime?: Prisma.SortOrder
  maxDuration?: Prisma.SortOrder
  summaryText?: Prisma.SortOrder
  pausedAt?: Prisma.SortOrder
  completedAt?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type ReflectionSessionSumOrderByAggregateInput = {
  recordingAttempt?: Prisma.SortOrder
  totalUserSpeakingTime?: Prisma.SortOrder
  maxDuration?: Prisma.SortOrder
}

export type ReflectionSessionScalarRelationFilter = {
  is?: Prisma.ReflectionSessionWhereInput
  isNot?: Prisma.ReflectionSessionWhereInput
}

export type ReflectionSessionCreateNestedManyWithoutUserInput = {
  create?:
    | Prisma.XOR<
        Prisma.ReflectionSessionCreateWithoutUserInput,
        Prisma.ReflectionSessionUncheckedCreateWithoutUserInput
      >
    | Prisma.ReflectionSessionCreateWithoutUserInput[]
    | Prisma.ReflectionSessionUncheckedCreateWithoutUserInput[]
  connectOrCreate?:
    | Prisma.ReflectionSessionCreateOrConnectWithoutUserInput
    | Prisma.ReflectionSessionCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.ReflectionSessionCreateManyUserInputEnvelope
  connect?:
    | Prisma.ReflectionSessionWhereUniqueInput
    | Prisma.ReflectionSessionWhereUniqueInput[]
}

export type ReflectionSessionUncheckedCreateNestedManyWithoutUserInput = {
  create?:
    | Prisma.XOR<
        Prisma.ReflectionSessionCreateWithoutUserInput,
        Prisma.ReflectionSessionUncheckedCreateWithoutUserInput
      >
    | Prisma.ReflectionSessionCreateWithoutUserInput[]
    | Prisma.ReflectionSessionUncheckedCreateWithoutUserInput[]
  connectOrCreate?:
    | Prisma.ReflectionSessionCreateOrConnectWithoutUserInput
    | Prisma.ReflectionSessionCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.ReflectionSessionCreateManyUserInputEnvelope
  connect?:
    | Prisma.ReflectionSessionWhereUniqueInput
    | Prisma.ReflectionSessionWhereUniqueInput[]
}

export type ReflectionSessionUpdateManyWithoutUserNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.ReflectionSessionCreateWithoutUserInput,
        Prisma.ReflectionSessionUncheckedCreateWithoutUserInput
      >
    | Prisma.ReflectionSessionCreateWithoutUserInput[]
    | Prisma.ReflectionSessionUncheckedCreateWithoutUserInput[]
  connectOrCreate?:
    | Prisma.ReflectionSessionCreateOrConnectWithoutUserInput
    | Prisma.ReflectionSessionCreateOrConnectWithoutUserInput[]
  upsert?:
    | Prisma.ReflectionSessionUpsertWithWhereUniqueWithoutUserInput
    | Prisma.ReflectionSessionUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.ReflectionSessionCreateManyUserInputEnvelope
  set?:
    | Prisma.ReflectionSessionWhereUniqueInput
    | Prisma.ReflectionSessionWhereUniqueInput[]
  disconnect?:
    | Prisma.ReflectionSessionWhereUniqueInput
    | Prisma.ReflectionSessionWhereUniqueInput[]
  delete?:
    | Prisma.ReflectionSessionWhereUniqueInput
    | Prisma.ReflectionSessionWhereUniqueInput[]
  connect?:
    | Prisma.ReflectionSessionWhereUniqueInput
    | Prisma.ReflectionSessionWhereUniqueInput[]
  update?:
    | Prisma.ReflectionSessionUpdateWithWhereUniqueWithoutUserInput
    | Prisma.ReflectionSessionUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?:
    | Prisma.ReflectionSessionUpdateManyWithWhereWithoutUserInput
    | Prisma.ReflectionSessionUpdateManyWithWhereWithoutUserInput[]
  deleteMany?:
    | Prisma.ReflectionSessionScalarWhereInput
    | Prisma.ReflectionSessionScalarWhereInput[]
}

export type ReflectionSessionUncheckedUpdateManyWithoutUserNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.ReflectionSessionCreateWithoutUserInput,
        Prisma.ReflectionSessionUncheckedCreateWithoutUserInput
      >
    | Prisma.ReflectionSessionCreateWithoutUserInput[]
    | Prisma.ReflectionSessionUncheckedCreateWithoutUserInput[]
  connectOrCreate?:
    | Prisma.ReflectionSessionCreateOrConnectWithoutUserInput
    | Prisma.ReflectionSessionCreateOrConnectWithoutUserInput[]
  upsert?:
    | Prisma.ReflectionSessionUpsertWithWhereUniqueWithoutUserInput
    | Prisma.ReflectionSessionUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.ReflectionSessionCreateManyUserInputEnvelope
  set?:
    | Prisma.ReflectionSessionWhereUniqueInput
    | Prisma.ReflectionSessionWhereUniqueInput[]
  disconnect?:
    | Prisma.ReflectionSessionWhereUniqueInput
    | Prisma.ReflectionSessionWhereUniqueInput[]
  delete?:
    | Prisma.ReflectionSessionWhereUniqueInput
    | Prisma.ReflectionSessionWhereUniqueInput[]
  connect?:
    | Prisma.ReflectionSessionWhereUniqueInput
    | Prisma.ReflectionSessionWhereUniqueInput[]
  update?:
    | Prisma.ReflectionSessionUpdateWithWhereUniqueWithoutUserInput
    | Prisma.ReflectionSessionUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?:
    | Prisma.ReflectionSessionUpdateManyWithWhereWithoutUserInput
    | Prisma.ReflectionSessionUpdateManyWithWhereWithoutUserInput[]
  deleteMany?:
    | Prisma.ReflectionSessionScalarWhereInput
    | Prisma.ReflectionSessionScalarWhereInput[]
}

export type ReflectionSessionCreateNestedOneWithoutTurnsInput = {
  create?: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutTurnsInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutTurnsInput
  >
  connectOrCreate?: Prisma.ReflectionSessionCreateOrConnectWithoutTurnsInput
  connect?: Prisma.ReflectionSessionWhereUniqueInput
}

export type ReflectionSessionUpdateOneRequiredWithoutTurnsNestedInput = {
  create?: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutTurnsInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutTurnsInput
  >
  connectOrCreate?: Prisma.ReflectionSessionCreateOrConnectWithoutTurnsInput
  upsert?: Prisma.ReflectionSessionUpsertWithoutTurnsInput
  connect?: Prisma.ReflectionSessionWhereUniqueInput
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.ReflectionSessionUpdateToOneWithWhereWithoutTurnsInput,
      Prisma.ReflectionSessionUpdateWithoutTurnsInput
    >,
    Prisma.ReflectionSessionUncheckedUpdateWithoutTurnsInput
  >
}

export type ReflectionSessionCreateNestedOneWithoutMoodInput = {
  create?: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutMoodInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutMoodInput
  >
  connectOrCreate?: Prisma.ReflectionSessionCreateOrConnectWithoutMoodInput
  connect?: Prisma.ReflectionSessionWhereUniqueInput
}

export type ReflectionSessionUpdateOneRequiredWithoutMoodNestedInput = {
  create?: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutMoodInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutMoodInput
  >
  connectOrCreate?: Prisma.ReflectionSessionCreateOrConnectWithoutMoodInput
  upsert?: Prisma.ReflectionSessionUpsertWithoutMoodInput
  connect?: Prisma.ReflectionSessionWhereUniqueInput
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.ReflectionSessionUpdateToOneWithWhereWithoutMoodInput,
      Prisma.ReflectionSessionUpdateWithoutMoodInput
    >,
    Prisma.ReflectionSessionUncheckedUpdateWithoutMoodInput
  >
}

export type ReflectionSessionCreateNestedOneWithoutTopicsInput = {
  create?: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutTopicsInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutTopicsInput
  >
  connectOrCreate?: Prisma.ReflectionSessionCreateOrConnectWithoutTopicsInput
  connect?: Prisma.ReflectionSessionWhereUniqueInput
}

export type ReflectionSessionUpdateOneRequiredWithoutTopicsNestedInput = {
  create?: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutTopicsInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutTopicsInput
  >
  connectOrCreate?: Prisma.ReflectionSessionCreateOrConnectWithoutTopicsInput
  upsert?: Prisma.ReflectionSessionUpsertWithoutTopicsInput
  connect?: Prisma.ReflectionSessionWhereUniqueInput
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.ReflectionSessionUpdateToOneWithWhereWithoutTopicsInput,
      Prisma.ReflectionSessionUpdateWithoutTopicsInput
    >,
    Prisma.ReflectionSessionUncheckedUpdateWithoutTopicsInput
  >
}

export type ReflectionSessionCreateNestedOneWithoutInsightsInput = {
  create?: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutInsightsInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutInsightsInput
  >
  connectOrCreate?: Prisma.ReflectionSessionCreateOrConnectWithoutInsightsInput
  connect?: Prisma.ReflectionSessionWhereUniqueInput
}

export type ReflectionSessionUpdateOneRequiredWithoutInsightsNestedInput = {
  create?: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutInsightsInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutInsightsInput
  >
  connectOrCreate?: Prisma.ReflectionSessionCreateOrConnectWithoutInsightsInput
  upsert?: Prisma.ReflectionSessionUpsertWithoutInsightsInput
  connect?: Prisma.ReflectionSessionWhereUniqueInput
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.ReflectionSessionUpdateToOneWithWhereWithoutInsightsInput,
      Prisma.ReflectionSessionUpdateWithoutInsightsInput
    >,
    Prisma.ReflectionSessionUncheckedUpdateWithoutInsightsInput
  >
}

export type ReflectionSessionCreateNestedOneWithoutPersonMentionsInput = {
  create?: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutPersonMentionsInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutPersonMentionsInput
  >
  connectOrCreate?: Prisma.ReflectionSessionCreateOrConnectWithoutPersonMentionsInput
  connect?: Prisma.ReflectionSessionWhereUniqueInput
}

export type ReflectionSessionUpdateOneRequiredWithoutPersonMentionsNestedInput =
  {
    create?: Prisma.XOR<
      Prisma.ReflectionSessionCreateWithoutPersonMentionsInput,
      Prisma.ReflectionSessionUncheckedCreateWithoutPersonMentionsInput
    >
    connectOrCreate?: Prisma.ReflectionSessionCreateOrConnectWithoutPersonMentionsInput
    upsert?: Prisma.ReflectionSessionUpsertWithoutPersonMentionsInput
    connect?: Prisma.ReflectionSessionWhereUniqueInput
    update?: Prisma.XOR<
      Prisma.XOR<
        Prisma.ReflectionSessionUpdateToOneWithWhereWithoutPersonMentionsInput,
        Prisma.ReflectionSessionUpdateWithoutPersonMentionsInput
      >,
      Prisma.ReflectionSessionUncheckedUpdateWithoutPersonMentionsInput
    >
  }

export type ReflectionSessionCreateWithoutUserInput = {
  id?: string
  date: Date | string
  status?: string
  recordingAttempt?: number
  totalUserSpeakingTime?: number
  maxDuration?: number
  summaryText?: string | null
  pausedAt?: Date | string | null
  completedAt?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  turns?: Prisma.ReflectionTurnCreateNestedManyWithoutSessionInput
  mood?: Prisma.ReflectionMoodCreateNestedOneWithoutSessionInput
  topics?: Prisma.ReflectionTopicCreateNestedManyWithoutSessionInput
  insights?: Prisma.ReflectionInsightCreateNestedManyWithoutSessionInput
  personMentions?: Prisma.PersonMentionCreateNestedManyWithoutSessionInput
}

export type ReflectionSessionUncheckedCreateWithoutUserInput = {
  id?: string
  date: Date | string
  status?: string
  recordingAttempt?: number
  totalUserSpeakingTime?: number
  maxDuration?: number
  summaryText?: string | null
  pausedAt?: Date | string | null
  completedAt?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  turns?: Prisma.ReflectionTurnUncheckedCreateNestedManyWithoutSessionInput
  mood?: Prisma.ReflectionMoodUncheckedCreateNestedOneWithoutSessionInput
  topics?: Prisma.ReflectionTopicUncheckedCreateNestedManyWithoutSessionInput
  insights?: Prisma.ReflectionInsightUncheckedCreateNestedManyWithoutSessionInput
  personMentions?: Prisma.PersonMentionUncheckedCreateNestedManyWithoutSessionInput
}

export type ReflectionSessionCreateOrConnectWithoutUserInput = {
  where: Prisma.ReflectionSessionWhereUniqueInput
  create: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutUserInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutUserInput
  >
}

export type ReflectionSessionCreateManyUserInputEnvelope = {
  data:
    | Prisma.ReflectionSessionCreateManyUserInput
    | Prisma.ReflectionSessionCreateManyUserInput[]
}

export type ReflectionSessionUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.ReflectionSessionWhereUniqueInput
  update: Prisma.XOR<
    Prisma.ReflectionSessionUpdateWithoutUserInput,
    Prisma.ReflectionSessionUncheckedUpdateWithoutUserInput
  >
  create: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutUserInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutUserInput
  >
}

export type ReflectionSessionUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.ReflectionSessionWhereUniqueInput
  data: Prisma.XOR<
    Prisma.ReflectionSessionUpdateWithoutUserInput,
    Prisma.ReflectionSessionUncheckedUpdateWithoutUserInput
  >
}

export type ReflectionSessionUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.ReflectionSessionScalarWhereInput
  data: Prisma.XOR<
    Prisma.ReflectionSessionUpdateManyMutationInput,
    Prisma.ReflectionSessionUncheckedUpdateManyWithoutUserInput
  >
}

export type ReflectionSessionScalarWhereInput = {
  AND?:
    | Prisma.ReflectionSessionScalarWhereInput
    | Prisma.ReflectionSessionScalarWhereInput[]
  OR?: Prisma.ReflectionSessionScalarWhereInput[]
  NOT?:
    | Prisma.ReflectionSessionScalarWhereInput
    | Prisma.ReflectionSessionScalarWhereInput[]
  id?: Prisma.StringFilter<'ReflectionSession'> | string
  userId?: Prisma.StringFilter<'ReflectionSession'> | string
  date?: Prisma.DateTimeFilter<'ReflectionSession'> | Date | string
  status?: Prisma.StringFilter<'ReflectionSession'> | string
  recordingAttempt?: Prisma.IntFilter<'ReflectionSession'> | number
  totalUserSpeakingTime?: Prisma.IntFilter<'ReflectionSession'> | number
  maxDuration?: Prisma.IntFilter<'ReflectionSession'> | number
  summaryText?: Prisma.StringNullableFilter<'ReflectionSession'> | string | null
  pausedAt?:
    | Prisma.DateTimeNullableFilter<'ReflectionSession'>
    | Date
    | string
    | null
  completedAt?:
    | Prisma.DateTimeNullableFilter<'ReflectionSession'>
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFilter<'ReflectionSession'> | Date | string
  updatedAt?: Prisma.DateTimeFilter<'ReflectionSession'> | Date | string
}

export type ReflectionSessionCreateWithoutTurnsInput = {
  id?: string
  date: Date | string
  status?: string
  recordingAttempt?: number
  totalUserSpeakingTime?: number
  maxDuration?: number
  summaryText?: string | null
  pausedAt?: Date | string | null
  completedAt?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutReflectionSessionsInput
  mood?: Prisma.ReflectionMoodCreateNestedOneWithoutSessionInput
  topics?: Prisma.ReflectionTopicCreateNestedManyWithoutSessionInput
  insights?: Prisma.ReflectionInsightCreateNestedManyWithoutSessionInput
  personMentions?: Prisma.PersonMentionCreateNestedManyWithoutSessionInput
}

export type ReflectionSessionUncheckedCreateWithoutTurnsInput = {
  id?: string
  userId: string
  date: Date | string
  status?: string
  recordingAttempt?: number
  totalUserSpeakingTime?: number
  maxDuration?: number
  summaryText?: string | null
  pausedAt?: Date | string | null
  completedAt?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  mood?: Prisma.ReflectionMoodUncheckedCreateNestedOneWithoutSessionInput
  topics?: Prisma.ReflectionTopicUncheckedCreateNestedManyWithoutSessionInput
  insights?: Prisma.ReflectionInsightUncheckedCreateNestedManyWithoutSessionInput
  personMentions?: Prisma.PersonMentionUncheckedCreateNestedManyWithoutSessionInput
}

export type ReflectionSessionCreateOrConnectWithoutTurnsInput = {
  where: Prisma.ReflectionSessionWhereUniqueInput
  create: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutTurnsInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutTurnsInput
  >
}

export type ReflectionSessionUpsertWithoutTurnsInput = {
  update: Prisma.XOR<
    Prisma.ReflectionSessionUpdateWithoutTurnsInput,
    Prisma.ReflectionSessionUncheckedUpdateWithoutTurnsInput
  >
  create: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutTurnsInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutTurnsInput
  >
  where?: Prisma.ReflectionSessionWhereInput
}

export type ReflectionSessionUpdateToOneWithWhereWithoutTurnsInput = {
  where?: Prisma.ReflectionSessionWhereInput
  data: Prisma.XOR<
    Prisma.ReflectionSessionUpdateWithoutTurnsInput,
    Prisma.ReflectionSessionUncheckedUpdateWithoutTurnsInput
  >
}

export type ReflectionSessionUpdateWithoutTurnsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  recordingAttempt?: Prisma.IntFieldUpdateOperationsInput | number
  totalUserSpeakingTime?: Prisma.IntFieldUpdateOperationsInput | number
  maxDuration?: Prisma.IntFieldUpdateOperationsInput | number
  summaryText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  pausedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  completedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutReflectionSessionsNestedInput
  mood?: Prisma.ReflectionMoodUpdateOneWithoutSessionNestedInput
  topics?: Prisma.ReflectionTopicUpdateManyWithoutSessionNestedInput
  insights?: Prisma.ReflectionInsightUpdateManyWithoutSessionNestedInput
  personMentions?: Prisma.PersonMentionUpdateManyWithoutSessionNestedInput
}

export type ReflectionSessionUncheckedUpdateWithoutTurnsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  recordingAttempt?: Prisma.IntFieldUpdateOperationsInput | number
  totalUserSpeakingTime?: Prisma.IntFieldUpdateOperationsInput | number
  maxDuration?: Prisma.IntFieldUpdateOperationsInput | number
  summaryText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  pausedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  completedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  mood?: Prisma.ReflectionMoodUncheckedUpdateOneWithoutSessionNestedInput
  topics?: Prisma.ReflectionTopicUncheckedUpdateManyWithoutSessionNestedInput
  insights?: Prisma.ReflectionInsightUncheckedUpdateManyWithoutSessionNestedInput
  personMentions?: Prisma.PersonMentionUncheckedUpdateManyWithoutSessionNestedInput
}

export type ReflectionSessionCreateWithoutMoodInput = {
  id?: string
  date: Date | string
  status?: string
  recordingAttempt?: number
  totalUserSpeakingTime?: number
  maxDuration?: number
  summaryText?: string | null
  pausedAt?: Date | string | null
  completedAt?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutReflectionSessionsInput
  turns?: Prisma.ReflectionTurnCreateNestedManyWithoutSessionInput
  topics?: Prisma.ReflectionTopicCreateNestedManyWithoutSessionInput
  insights?: Prisma.ReflectionInsightCreateNestedManyWithoutSessionInput
  personMentions?: Prisma.PersonMentionCreateNestedManyWithoutSessionInput
}

export type ReflectionSessionUncheckedCreateWithoutMoodInput = {
  id?: string
  userId: string
  date: Date | string
  status?: string
  recordingAttempt?: number
  totalUserSpeakingTime?: number
  maxDuration?: number
  summaryText?: string | null
  pausedAt?: Date | string | null
  completedAt?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  turns?: Prisma.ReflectionTurnUncheckedCreateNestedManyWithoutSessionInput
  topics?: Prisma.ReflectionTopicUncheckedCreateNestedManyWithoutSessionInput
  insights?: Prisma.ReflectionInsightUncheckedCreateNestedManyWithoutSessionInput
  personMentions?: Prisma.PersonMentionUncheckedCreateNestedManyWithoutSessionInput
}

export type ReflectionSessionCreateOrConnectWithoutMoodInput = {
  where: Prisma.ReflectionSessionWhereUniqueInput
  create: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutMoodInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutMoodInput
  >
}

export type ReflectionSessionUpsertWithoutMoodInput = {
  update: Prisma.XOR<
    Prisma.ReflectionSessionUpdateWithoutMoodInput,
    Prisma.ReflectionSessionUncheckedUpdateWithoutMoodInput
  >
  create: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutMoodInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutMoodInput
  >
  where?: Prisma.ReflectionSessionWhereInput
}

export type ReflectionSessionUpdateToOneWithWhereWithoutMoodInput = {
  where?: Prisma.ReflectionSessionWhereInput
  data: Prisma.XOR<
    Prisma.ReflectionSessionUpdateWithoutMoodInput,
    Prisma.ReflectionSessionUncheckedUpdateWithoutMoodInput
  >
}

export type ReflectionSessionUpdateWithoutMoodInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  recordingAttempt?: Prisma.IntFieldUpdateOperationsInput | number
  totalUserSpeakingTime?: Prisma.IntFieldUpdateOperationsInput | number
  maxDuration?: Prisma.IntFieldUpdateOperationsInput | number
  summaryText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  pausedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  completedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutReflectionSessionsNestedInput
  turns?: Prisma.ReflectionTurnUpdateManyWithoutSessionNestedInput
  topics?: Prisma.ReflectionTopicUpdateManyWithoutSessionNestedInput
  insights?: Prisma.ReflectionInsightUpdateManyWithoutSessionNestedInput
  personMentions?: Prisma.PersonMentionUpdateManyWithoutSessionNestedInput
}

export type ReflectionSessionUncheckedUpdateWithoutMoodInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  recordingAttempt?: Prisma.IntFieldUpdateOperationsInput | number
  totalUserSpeakingTime?: Prisma.IntFieldUpdateOperationsInput | number
  maxDuration?: Prisma.IntFieldUpdateOperationsInput | number
  summaryText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  pausedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  completedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  turns?: Prisma.ReflectionTurnUncheckedUpdateManyWithoutSessionNestedInput
  topics?: Prisma.ReflectionTopicUncheckedUpdateManyWithoutSessionNestedInput
  insights?: Prisma.ReflectionInsightUncheckedUpdateManyWithoutSessionNestedInput
  personMentions?: Prisma.PersonMentionUncheckedUpdateManyWithoutSessionNestedInput
}

export type ReflectionSessionCreateWithoutTopicsInput = {
  id?: string
  date: Date | string
  status?: string
  recordingAttempt?: number
  totalUserSpeakingTime?: number
  maxDuration?: number
  summaryText?: string | null
  pausedAt?: Date | string | null
  completedAt?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutReflectionSessionsInput
  turns?: Prisma.ReflectionTurnCreateNestedManyWithoutSessionInput
  mood?: Prisma.ReflectionMoodCreateNestedOneWithoutSessionInput
  insights?: Prisma.ReflectionInsightCreateNestedManyWithoutSessionInput
  personMentions?: Prisma.PersonMentionCreateNestedManyWithoutSessionInput
}

export type ReflectionSessionUncheckedCreateWithoutTopicsInput = {
  id?: string
  userId: string
  date: Date | string
  status?: string
  recordingAttempt?: number
  totalUserSpeakingTime?: number
  maxDuration?: number
  summaryText?: string | null
  pausedAt?: Date | string | null
  completedAt?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  turns?: Prisma.ReflectionTurnUncheckedCreateNestedManyWithoutSessionInput
  mood?: Prisma.ReflectionMoodUncheckedCreateNestedOneWithoutSessionInput
  insights?: Prisma.ReflectionInsightUncheckedCreateNestedManyWithoutSessionInput
  personMentions?: Prisma.PersonMentionUncheckedCreateNestedManyWithoutSessionInput
}

export type ReflectionSessionCreateOrConnectWithoutTopicsInput = {
  where: Prisma.ReflectionSessionWhereUniqueInput
  create: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutTopicsInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutTopicsInput
  >
}

export type ReflectionSessionUpsertWithoutTopicsInput = {
  update: Prisma.XOR<
    Prisma.ReflectionSessionUpdateWithoutTopicsInput,
    Prisma.ReflectionSessionUncheckedUpdateWithoutTopicsInput
  >
  create: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutTopicsInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutTopicsInput
  >
  where?: Prisma.ReflectionSessionWhereInput
}

export type ReflectionSessionUpdateToOneWithWhereWithoutTopicsInput = {
  where?: Prisma.ReflectionSessionWhereInput
  data: Prisma.XOR<
    Prisma.ReflectionSessionUpdateWithoutTopicsInput,
    Prisma.ReflectionSessionUncheckedUpdateWithoutTopicsInput
  >
}

export type ReflectionSessionUpdateWithoutTopicsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  recordingAttempt?: Prisma.IntFieldUpdateOperationsInput | number
  totalUserSpeakingTime?: Prisma.IntFieldUpdateOperationsInput | number
  maxDuration?: Prisma.IntFieldUpdateOperationsInput | number
  summaryText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  pausedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  completedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutReflectionSessionsNestedInput
  turns?: Prisma.ReflectionTurnUpdateManyWithoutSessionNestedInput
  mood?: Prisma.ReflectionMoodUpdateOneWithoutSessionNestedInput
  insights?: Prisma.ReflectionInsightUpdateManyWithoutSessionNestedInput
  personMentions?: Prisma.PersonMentionUpdateManyWithoutSessionNestedInput
}

export type ReflectionSessionUncheckedUpdateWithoutTopicsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  recordingAttempt?: Prisma.IntFieldUpdateOperationsInput | number
  totalUserSpeakingTime?: Prisma.IntFieldUpdateOperationsInput | number
  maxDuration?: Prisma.IntFieldUpdateOperationsInput | number
  summaryText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  pausedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  completedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  turns?: Prisma.ReflectionTurnUncheckedUpdateManyWithoutSessionNestedInput
  mood?: Prisma.ReflectionMoodUncheckedUpdateOneWithoutSessionNestedInput
  insights?: Prisma.ReflectionInsightUncheckedUpdateManyWithoutSessionNestedInput
  personMentions?: Prisma.PersonMentionUncheckedUpdateManyWithoutSessionNestedInput
}

export type ReflectionSessionCreateWithoutInsightsInput = {
  id?: string
  date: Date | string
  status?: string
  recordingAttempt?: number
  totalUserSpeakingTime?: number
  maxDuration?: number
  summaryText?: string | null
  pausedAt?: Date | string | null
  completedAt?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutReflectionSessionsInput
  turns?: Prisma.ReflectionTurnCreateNestedManyWithoutSessionInput
  mood?: Prisma.ReflectionMoodCreateNestedOneWithoutSessionInput
  topics?: Prisma.ReflectionTopicCreateNestedManyWithoutSessionInput
  personMentions?: Prisma.PersonMentionCreateNestedManyWithoutSessionInput
}

export type ReflectionSessionUncheckedCreateWithoutInsightsInput = {
  id?: string
  userId: string
  date: Date | string
  status?: string
  recordingAttempt?: number
  totalUserSpeakingTime?: number
  maxDuration?: number
  summaryText?: string | null
  pausedAt?: Date | string | null
  completedAt?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  turns?: Prisma.ReflectionTurnUncheckedCreateNestedManyWithoutSessionInput
  mood?: Prisma.ReflectionMoodUncheckedCreateNestedOneWithoutSessionInput
  topics?: Prisma.ReflectionTopicUncheckedCreateNestedManyWithoutSessionInput
  personMentions?: Prisma.PersonMentionUncheckedCreateNestedManyWithoutSessionInput
}

export type ReflectionSessionCreateOrConnectWithoutInsightsInput = {
  where: Prisma.ReflectionSessionWhereUniqueInput
  create: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutInsightsInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutInsightsInput
  >
}

export type ReflectionSessionUpsertWithoutInsightsInput = {
  update: Prisma.XOR<
    Prisma.ReflectionSessionUpdateWithoutInsightsInput,
    Prisma.ReflectionSessionUncheckedUpdateWithoutInsightsInput
  >
  create: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutInsightsInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutInsightsInput
  >
  where?: Prisma.ReflectionSessionWhereInput
}

export type ReflectionSessionUpdateToOneWithWhereWithoutInsightsInput = {
  where?: Prisma.ReflectionSessionWhereInput
  data: Prisma.XOR<
    Prisma.ReflectionSessionUpdateWithoutInsightsInput,
    Prisma.ReflectionSessionUncheckedUpdateWithoutInsightsInput
  >
}

export type ReflectionSessionUpdateWithoutInsightsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  recordingAttempt?: Prisma.IntFieldUpdateOperationsInput | number
  totalUserSpeakingTime?: Prisma.IntFieldUpdateOperationsInput | number
  maxDuration?: Prisma.IntFieldUpdateOperationsInput | number
  summaryText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  pausedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  completedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutReflectionSessionsNestedInput
  turns?: Prisma.ReflectionTurnUpdateManyWithoutSessionNestedInput
  mood?: Prisma.ReflectionMoodUpdateOneWithoutSessionNestedInput
  topics?: Prisma.ReflectionTopicUpdateManyWithoutSessionNestedInput
  personMentions?: Prisma.PersonMentionUpdateManyWithoutSessionNestedInput
}

export type ReflectionSessionUncheckedUpdateWithoutInsightsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  recordingAttempt?: Prisma.IntFieldUpdateOperationsInput | number
  totalUserSpeakingTime?: Prisma.IntFieldUpdateOperationsInput | number
  maxDuration?: Prisma.IntFieldUpdateOperationsInput | number
  summaryText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  pausedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  completedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  turns?: Prisma.ReflectionTurnUncheckedUpdateManyWithoutSessionNestedInput
  mood?: Prisma.ReflectionMoodUncheckedUpdateOneWithoutSessionNestedInput
  topics?: Prisma.ReflectionTopicUncheckedUpdateManyWithoutSessionNestedInput
  personMentions?: Prisma.PersonMentionUncheckedUpdateManyWithoutSessionNestedInput
}

export type ReflectionSessionCreateWithoutPersonMentionsInput = {
  id?: string
  date: Date | string
  status?: string
  recordingAttempt?: number
  totalUserSpeakingTime?: number
  maxDuration?: number
  summaryText?: string | null
  pausedAt?: Date | string | null
  completedAt?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutReflectionSessionsInput
  turns?: Prisma.ReflectionTurnCreateNestedManyWithoutSessionInput
  mood?: Prisma.ReflectionMoodCreateNestedOneWithoutSessionInput
  topics?: Prisma.ReflectionTopicCreateNestedManyWithoutSessionInput
  insights?: Prisma.ReflectionInsightCreateNestedManyWithoutSessionInput
}

export type ReflectionSessionUncheckedCreateWithoutPersonMentionsInput = {
  id?: string
  userId: string
  date: Date | string
  status?: string
  recordingAttempt?: number
  totalUserSpeakingTime?: number
  maxDuration?: number
  summaryText?: string | null
  pausedAt?: Date | string | null
  completedAt?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  turns?: Prisma.ReflectionTurnUncheckedCreateNestedManyWithoutSessionInput
  mood?: Prisma.ReflectionMoodUncheckedCreateNestedOneWithoutSessionInput
  topics?: Prisma.ReflectionTopicUncheckedCreateNestedManyWithoutSessionInput
  insights?: Prisma.ReflectionInsightUncheckedCreateNestedManyWithoutSessionInput
}

export type ReflectionSessionCreateOrConnectWithoutPersonMentionsInput = {
  where: Prisma.ReflectionSessionWhereUniqueInput
  create: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutPersonMentionsInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutPersonMentionsInput
  >
}

export type ReflectionSessionUpsertWithoutPersonMentionsInput = {
  update: Prisma.XOR<
    Prisma.ReflectionSessionUpdateWithoutPersonMentionsInput,
    Prisma.ReflectionSessionUncheckedUpdateWithoutPersonMentionsInput
  >
  create: Prisma.XOR<
    Prisma.ReflectionSessionCreateWithoutPersonMentionsInput,
    Prisma.ReflectionSessionUncheckedCreateWithoutPersonMentionsInput
  >
  where?: Prisma.ReflectionSessionWhereInput
}

export type ReflectionSessionUpdateToOneWithWhereWithoutPersonMentionsInput = {
  where?: Prisma.ReflectionSessionWhereInput
  data: Prisma.XOR<
    Prisma.ReflectionSessionUpdateWithoutPersonMentionsInput,
    Prisma.ReflectionSessionUncheckedUpdateWithoutPersonMentionsInput
  >
}

export type ReflectionSessionUpdateWithoutPersonMentionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  recordingAttempt?: Prisma.IntFieldUpdateOperationsInput | number
  totalUserSpeakingTime?: Prisma.IntFieldUpdateOperationsInput | number
  maxDuration?: Prisma.IntFieldUpdateOperationsInput | number
  summaryText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  pausedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  completedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutReflectionSessionsNestedInput
  turns?: Prisma.ReflectionTurnUpdateManyWithoutSessionNestedInput
  mood?: Prisma.ReflectionMoodUpdateOneWithoutSessionNestedInput
  topics?: Prisma.ReflectionTopicUpdateManyWithoutSessionNestedInput
  insights?: Prisma.ReflectionInsightUpdateManyWithoutSessionNestedInput
}

export type ReflectionSessionUncheckedUpdateWithoutPersonMentionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  recordingAttempt?: Prisma.IntFieldUpdateOperationsInput | number
  totalUserSpeakingTime?: Prisma.IntFieldUpdateOperationsInput | number
  maxDuration?: Prisma.IntFieldUpdateOperationsInput | number
  summaryText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  pausedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  completedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  turns?: Prisma.ReflectionTurnUncheckedUpdateManyWithoutSessionNestedInput
  mood?: Prisma.ReflectionMoodUncheckedUpdateOneWithoutSessionNestedInput
  topics?: Prisma.ReflectionTopicUncheckedUpdateManyWithoutSessionNestedInput
  insights?: Prisma.ReflectionInsightUncheckedUpdateManyWithoutSessionNestedInput
}

export type ReflectionSessionCreateManyUserInput = {
  id?: string
  date: Date | string
  status?: string
  recordingAttempt?: number
  totalUserSpeakingTime?: number
  maxDuration?: number
  summaryText?: string | null
  pausedAt?: Date | string | null
  completedAt?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type ReflectionSessionUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  recordingAttempt?: Prisma.IntFieldUpdateOperationsInput | number
  totalUserSpeakingTime?: Prisma.IntFieldUpdateOperationsInput | number
  maxDuration?: Prisma.IntFieldUpdateOperationsInput | number
  summaryText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  pausedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  completedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  turns?: Prisma.ReflectionTurnUpdateManyWithoutSessionNestedInput
  mood?: Prisma.ReflectionMoodUpdateOneWithoutSessionNestedInput
  topics?: Prisma.ReflectionTopicUpdateManyWithoutSessionNestedInput
  insights?: Prisma.ReflectionInsightUpdateManyWithoutSessionNestedInput
  personMentions?: Prisma.PersonMentionUpdateManyWithoutSessionNestedInput
}

export type ReflectionSessionUncheckedUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  recordingAttempt?: Prisma.IntFieldUpdateOperationsInput | number
  totalUserSpeakingTime?: Prisma.IntFieldUpdateOperationsInput | number
  maxDuration?: Prisma.IntFieldUpdateOperationsInput | number
  summaryText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  pausedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  completedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  turns?: Prisma.ReflectionTurnUncheckedUpdateManyWithoutSessionNestedInput
  mood?: Prisma.ReflectionMoodUncheckedUpdateOneWithoutSessionNestedInput
  topics?: Prisma.ReflectionTopicUncheckedUpdateManyWithoutSessionNestedInput
  insights?: Prisma.ReflectionInsightUncheckedUpdateManyWithoutSessionNestedInput
  personMentions?: Prisma.PersonMentionUncheckedUpdateManyWithoutSessionNestedInput
}

export type ReflectionSessionUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  recordingAttempt?: Prisma.IntFieldUpdateOperationsInput | number
  totalUserSpeakingTime?: Prisma.IntFieldUpdateOperationsInput | number
  maxDuration?: Prisma.IntFieldUpdateOperationsInput | number
  summaryText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  pausedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  completedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

/**
 * Count Type ReflectionSessionCountOutputType
 */

export type ReflectionSessionCountOutputType = {
  turns: number
  topics: number
  insights: number
  personMentions: number
}

export type ReflectionSessionCountOutputTypeSelect<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  turns?: boolean | ReflectionSessionCountOutputTypeCountTurnsArgs
  topics?: boolean | ReflectionSessionCountOutputTypeCountTopicsArgs
  insights?: boolean | ReflectionSessionCountOutputTypeCountInsightsArgs
  personMentions?:
    | boolean
    | ReflectionSessionCountOutputTypeCountPersonMentionsArgs
}

/**
 * ReflectionSessionCountOutputType without action
 */
export type ReflectionSessionCountOutputTypeDefaultArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ReflectionSessionCountOutputType
   */
  select?: Prisma.ReflectionSessionCountOutputTypeSelect<ExtArgs> | null
}

/**
 * ReflectionSessionCountOutputType without action
 */
export type ReflectionSessionCountOutputTypeCountTurnsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.ReflectionTurnWhereInput
}

/**
 * ReflectionSessionCountOutputType without action
 */
export type ReflectionSessionCountOutputTypeCountTopicsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.ReflectionTopicWhereInput
}

/**
 * ReflectionSessionCountOutputType without action
 */
export type ReflectionSessionCountOutputTypeCountInsightsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.ReflectionInsightWhereInput
}

/**
 * ReflectionSessionCountOutputType without action
 */
export type ReflectionSessionCountOutputTypeCountPersonMentionsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.PersonMentionWhereInput
}

export type ReflectionSessionSelect<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean
    userId?: boolean
    date?: boolean
    status?: boolean
    recordingAttempt?: boolean
    totalUserSpeakingTime?: boolean
    maxDuration?: boolean
    summaryText?: boolean
    pausedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
    turns?: boolean | Prisma.ReflectionSession$turnsArgs<ExtArgs>
    mood?: boolean | Prisma.ReflectionSession$moodArgs<ExtArgs>
    topics?: boolean | Prisma.ReflectionSession$topicsArgs<ExtArgs>
    insights?: boolean | Prisma.ReflectionSession$insightsArgs<ExtArgs>
    personMentions?:
      | boolean
      | Prisma.ReflectionSession$personMentionsArgs<ExtArgs>
    _count?:
      | boolean
      | Prisma.ReflectionSessionCountOutputTypeDefaultArgs<ExtArgs>
  },
  ExtArgs['result']['reflectionSession']
>

export type ReflectionSessionSelectCreateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean
    userId?: boolean
    date?: boolean
    status?: boolean
    recordingAttempt?: boolean
    totalUserSpeakingTime?: boolean
    maxDuration?: boolean
    summaryText?: boolean
    pausedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  },
  ExtArgs['result']['reflectionSession']
>

export type ReflectionSessionSelectUpdateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean
    userId?: boolean
    date?: boolean
    status?: boolean
    recordingAttempt?: boolean
    totalUserSpeakingTime?: boolean
    maxDuration?: boolean
    summaryText?: boolean
    pausedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  },
  ExtArgs['result']['reflectionSession']
>

export type ReflectionSessionSelectScalar = {
  id?: boolean
  userId?: boolean
  date?: boolean
  status?: boolean
  recordingAttempt?: boolean
  totalUserSpeakingTime?: boolean
  maxDuration?: boolean
  summaryText?: boolean
  pausedAt?: boolean
  completedAt?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type ReflectionSessionOmit<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
  | 'id'
  | 'userId'
  | 'date'
  | 'status'
  | 'recordingAttempt'
  | 'totalUserSpeakingTime'
  | 'maxDuration'
  | 'summaryText'
  | 'pausedAt'
  | 'completedAt'
  | 'createdAt'
  | 'updatedAt',
  ExtArgs['result']['reflectionSession']
>
export type ReflectionSessionInclude<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  turns?: boolean | Prisma.ReflectionSession$turnsArgs<ExtArgs>
  mood?: boolean | Prisma.ReflectionSession$moodArgs<ExtArgs>
  topics?: boolean | Prisma.ReflectionSession$topicsArgs<ExtArgs>
  insights?: boolean | Prisma.ReflectionSession$insightsArgs<ExtArgs>
  personMentions?:
    | boolean
    | Prisma.ReflectionSession$personMentionsArgs<ExtArgs>
  _count?: boolean | Prisma.ReflectionSessionCountOutputTypeDefaultArgs<ExtArgs>
}
export type ReflectionSessionIncludeCreateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}
export type ReflectionSessionIncludeUpdateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}

export type $ReflectionSessionPayload<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  name: 'ReflectionSession'
  objects: {
    user: Prisma.$UserPayload<ExtArgs>
    turns: Prisma.$ReflectionTurnPayload<ExtArgs>[]
    mood: Prisma.$ReflectionMoodPayload<ExtArgs> | null
    topics: Prisma.$ReflectionTopicPayload<ExtArgs>[]
    insights: Prisma.$ReflectionInsightPayload<ExtArgs>[]
    personMentions: Prisma.$PersonMentionPayload<ExtArgs>[]
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<
    {
      id: string
      userId: string
      date: Date
      status: string
      recordingAttempt: number
      totalUserSpeakingTime: number
      maxDuration: number
      summaryText: string | null
      pausedAt: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    },
    ExtArgs['result']['reflectionSession']
  >
  composites: {}
}

export type ReflectionSessionGetPayload<
  S extends boolean | null | undefined | ReflectionSessionDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$ReflectionSessionPayload, S>

export type ReflectionSessionCountArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = Omit<
  ReflectionSessionFindManyArgs,
  'select' | 'include' | 'distinct' | 'omit'
> & {
  select?: ReflectionSessionCountAggregateInputType | true
}

export interface ReflectionSessionDelegate<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> {
  [K: symbol]: {
    types: Prisma.TypeMap<ExtArgs>['model']['ReflectionSession']
    meta: { name: 'ReflectionSession' }
  }
  /**
   * Find zero or one ReflectionSession that matches the filter.
   * @param {ReflectionSessionFindUniqueArgs} args - Arguments to find a ReflectionSession
   * @example
   * // Get one ReflectionSession
   * const reflectionSession = await prisma.reflectionSession.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends ReflectionSessionFindUniqueArgs>(
    args: Prisma.SelectSubset<T, ReflectionSessionFindUniqueArgs<ExtArgs>>,
  ): Prisma.Prisma__ReflectionSessionClient<
    runtime.Types.Result.GetResult<
      Prisma.$ReflectionSessionPayload<ExtArgs>,
      T,
      'findUnique',
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >

  /**
   * Find one ReflectionSession that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {ReflectionSessionFindUniqueOrThrowArgs} args - Arguments to find a ReflectionSession
   * @example
   * // Get one ReflectionSession
   * const reflectionSession = await prisma.reflectionSession.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends ReflectionSessionFindUniqueOrThrowArgs>(
    args: Prisma.SelectSubset<
      T,
      ReflectionSessionFindUniqueOrThrowArgs<ExtArgs>
    >,
  ): Prisma.Prisma__ReflectionSessionClient<
    runtime.Types.Result.GetResult<
      Prisma.$ReflectionSessionPayload<ExtArgs>,
      T,
      'findUniqueOrThrow',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >

  /**
   * Find the first ReflectionSession that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ReflectionSessionFindFirstArgs} args - Arguments to find a ReflectionSession
   * @example
   * // Get one ReflectionSession
   * const reflectionSession = await prisma.reflectionSession.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends ReflectionSessionFindFirstArgs>(
    args?: Prisma.SelectSubset<T, ReflectionSessionFindFirstArgs<ExtArgs>>,
  ): Prisma.Prisma__ReflectionSessionClient<
    runtime.Types.Result.GetResult<
      Prisma.$ReflectionSessionPayload<ExtArgs>,
      T,
      'findFirst',
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >

  /**
   * Find the first ReflectionSession that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ReflectionSessionFindFirstOrThrowArgs} args - Arguments to find a ReflectionSession
   * @example
   * // Get one ReflectionSession
   * const reflectionSession = await prisma.reflectionSession.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends ReflectionSessionFindFirstOrThrowArgs>(
    args?: Prisma.SelectSubset<
      T,
      ReflectionSessionFindFirstOrThrowArgs<ExtArgs>
    >,
  ): Prisma.Prisma__ReflectionSessionClient<
    runtime.Types.Result.GetResult<
      Prisma.$ReflectionSessionPayload<ExtArgs>,
      T,
      'findFirstOrThrow',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >

  /**
   * Find zero or more ReflectionSessions that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ReflectionSessionFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all ReflectionSessions
   * const reflectionSessions = await prisma.reflectionSession.findMany()
   *
   * // Get first 10 ReflectionSessions
   * const reflectionSessions = await prisma.reflectionSession.findMany({ take: 10 })
   *
   * // Only select the `id`
   * const reflectionSessionWithIdOnly = await prisma.reflectionSession.findMany({ select: { id: true } })
   *
   */
  findMany<T extends ReflectionSessionFindManyArgs>(
    args?: Prisma.SelectSubset<T, ReflectionSessionFindManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$ReflectionSessionPayload<ExtArgs>,
      T,
      'findMany',
      GlobalOmitOptions
    >
  >

  /**
   * Create a ReflectionSession.
   * @param {ReflectionSessionCreateArgs} args - Arguments to create a ReflectionSession.
   * @example
   * // Create one ReflectionSession
   * const ReflectionSession = await prisma.reflectionSession.create({
   *   data: {
   *     // ... data to create a ReflectionSession
   *   }
   * })
   *
   */
  create<T extends ReflectionSessionCreateArgs>(
    args: Prisma.SelectSubset<T, ReflectionSessionCreateArgs<ExtArgs>>,
  ): Prisma.Prisma__ReflectionSessionClient<
    runtime.Types.Result.GetResult<
      Prisma.$ReflectionSessionPayload<ExtArgs>,
      T,
      'create',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >

  /**
   * Create many ReflectionSessions.
   * @param {ReflectionSessionCreateManyArgs} args - Arguments to create many ReflectionSessions.
   * @example
   * // Create many ReflectionSessions
   * const reflectionSession = await prisma.reflectionSession.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   */
  createMany<T extends ReflectionSessionCreateManyArgs>(
    args?: Prisma.SelectSubset<T, ReflectionSessionCreateManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many ReflectionSessions and returns the data saved in the database.
   * @param {ReflectionSessionCreateManyAndReturnArgs} args - Arguments to create many ReflectionSessions.
   * @example
   * // Create many ReflectionSessions
   * const reflectionSession = await prisma.reflectionSession.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Create many ReflectionSessions and only return the `id`
   * const reflectionSessionWithIdOnly = await prisma.reflectionSession.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  createManyAndReturn<T extends ReflectionSessionCreateManyAndReturnArgs>(
    args?: Prisma.SelectSubset<
      T,
      ReflectionSessionCreateManyAndReturnArgs<ExtArgs>
    >,
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$ReflectionSessionPayload<ExtArgs>,
      T,
      'createManyAndReturn',
      GlobalOmitOptions
    >
  >

  /**
   * Delete a ReflectionSession.
   * @param {ReflectionSessionDeleteArgs} args - Arguments to delete one ReflectionSession.
   * @example
   * // Delete one ReflectionSession
   * const ReflectionSession = await prisma.reflectionSession.delete({
   *   where: {
   *     // ... filter to delete one ReflectionSession
   *   }
   * })
   *
   */
  delete<T extends ReflectionSessionDeleteArgs>(
    args: Prisma.SelectSubset<T, ReflectionSessionDeleteArgs<ExtArgs>>,
  ): Prisma.Prisma__ReflectionSessionClient<
    runtime.Types.Result.GetResult<
      Prisma.$ReflectionSessionPayload<ExtArgs>,
      T,
      'delete',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >

  /**
   * Update one ReflectionSession.
   * @param {ReflectionSessionUpdateArgs} args - Arguments to update one ReflectionSession.
   * @example
   * // Update one ReflectionSession
   * const reflectionSession = await prisma.reflectionSession.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  update<T extends ReflectionSessionUpdateArgs>(
    args: Prisma.SelectSubset<T, ReflectionSessionUpdateArgs<ExtArgs>>,
  ): Prisma.Prisma__ReflectionSessionClient<
    runtime.Types.Result.GetResult<
      Prisma.$ReflectionSessionPayload<ExtArgs>,
      T,
      'update',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >

  /**
   * Delete zero or more ReflectionSessions.
   * @param {ReflectionSessionDeleteManyArgs} args - Arguments to filter ReflectionSessions to delete.
   * @example
   * // Delete a few ReflectionSessions
   * const { count } = await prisma.reflectionSession.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   *
   */
  deleteMany<T extends ReflectionSessionDeleteManyArgs>(
    args?: Prisma.SelectSubset<T, ReflectionSessionDeleteManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ReflectionSessions.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ReflectionSessionUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many ReflectionSessions
   * const reflectionSession = await prisma.reflectionSession.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  updateMany<T extends ReflectionSessionUpdateManyArgs>(
    args: Prisma.SelectSubset<T, ReflectionSessionUpdateManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ReflectionSessions and returns the data updated in the database.
   * @param {ReflectionSessionUpdateManyAndReturnArgs} args - Arguments to update many ReflectionSessions.
   * @example
   * // Update many ReflectionSessions
   * const reflectionSession = await prisma.reflectionSession.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Update zero or more ReflectionSessions and only return the `id`
   * const reflectionSessionWithIdOnly = await prisma.reflectionSession.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  updateManyAndReturn<T extends ReflectionSessionUpdateManyAndReturnArgs>(
    args: Prisma.SelectSubset<
      T,
      ReflectionSessionUpdateManyAndReturnArgs<ExtArgs>
    >,
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$ReflectionSessionPayload<ExtArgs>,
      T,
      'updateManyAndReturn',
      GlobalOmitOptions
    >
  >

  /**
   * Create or update one ReflectionSession.
   * @param {ReflectionSessionUpsertArgs} args - Arguments to update or create a ReflectionSession.
   * @example
   * // Update or create a ReflectionSession
   * const reflectionSession = await prisma.reflectionSession.upsert({
   *   create: {
   *     // ... data to create a ReflectionSession
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the ReflectionSession we want to update
   *   }
   * })
   */
  upsert<T extends ReflectionSessionUpsertArgs>(
    args: Prisma.SelectSubset<T, ReflectionSessionUpsertArgs<ExtArgs>>,
  ): Prisma.Prisma__ReflectionSessionClient<
    runtime.Types.Result.GetResult<
      Prisma.$ReflectionSessionPayload<ExtArgs>,
      T,
      'upsert',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >

  /**
   * Count the number of ReflectionSessions.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ReflectionSessionCountArgs} args - Arguments to filter ReflectionSessions to count.
   * @example
   * // Count the number of ReflectionSessions
   * const count = await prisma.reflectionSession.count({
   *   where: {
   *     // ... the filter for the ReflectionSessions we want to count
   *   }
   * })
   **/
  count<T extends ReflectionSessionCountArgs>(
    args?: Prisma.Subset<T, ReflectionSessionCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<
            T['select'],
            ReflectionSessionCountAggregateOutputType
          >
      : number
  >

  /**
   * Allows you to perform aggregations operations on a ReflectionSession.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ReflectionSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
   **/
  aggregate<T extends ReflectionSessionAggregateArgs>(
    args: Prisma.Subset<T, ReflectionSessionAggregateArgs>,
  ): Prisma.PrismaPromise<GetReflectionSessionAggregateType<T>>

  /**
   * Group by ReflectionSession.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ReflectionSessionGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   *
   **/
  groupBy<
    T extends ReflectionSessionGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: ReflectionSessionGroupByArgs['orderBy'] }
      : { orderBy?: ReflectionSessionGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<
      Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>
    >,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
      ? `Error: "by" must not be empty.`
      : HavingValid extends Prisma.False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
                ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                : [
                    Error,
                    'Field ',
                    P,
                    ` in "having" needs to be provided in "by"`,
                  ]
          }[HavingFields]
        : 'take' extends Prisma.Keys<T>
          ? 'orderBy' extends Prisma.Keys<T>
            ? ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                }[OrderFields]
            : 'Error: If you provide "take", you also need to provide "orderBy"'
          : 'skip' extends Prisma.Keys<T>
            ? 'orderBy' extends Prisma.Keys<T>
              ? ByValid extends Prisma.True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "skip", you also need to provide "orderBy"'
            : ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                }[OrderFields],
  >(
    args: Prisma.SubsetIntersection<
      T,
      ReflectionSessionGroupByArgs,
      OrderByArg
    > &
      InputErrors,
  ): {} extends InputErrors
    ? GetReflectionSessionGroupByPayload<T>
    : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReflectionSession model
   */
  readonly fields: ReflectionSessionFieldRefs
}

/**
 * The delegate class that acts as a "Promise-like" for ReflectionSession.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ReflectionSessionClient<
  T,
  Null = never,
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: 'PrismaPromise'
  user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>,
  ): Prisma.Prisma__UserClient<
    | runtime.Types.Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >
    | Null,
    Null,
    ExtArgs,
    GlobalOmitOptions
  >
  turns<T extends Prisma.ReflectionSession$turnsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.ReflectionSession$turnsArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$ReflectionTurnPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    | Null
  >
  mood<T extends Prisma.ReflectionSession$moodArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.ReflectionSession$moodArgs<ExtArgs>>,
  ): Prisma.Prisma__ReflectionMoodClient<
    runtime.Types.Result.GetResult<
      Prisma.$ReflectionMoodPayload<ExtArgs>,
      T,
      'findUniqueOrThrow',
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >
  topics<T extends Prisma.ReflectionSession$topicsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.ReflectionSession$topicsArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$ReflectionTopicPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    | Null
  >
  insights<T extends Prisma.ReflectionSession$insightsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.ReflectionSession$insightsArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$ReflectionInsightPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    | Null
  >
  personMentions<
    T extends Prisma.ReflectionSession$personMentionsArgs<ExtArgs> = {},
  >(
    args?: Prisma.Subset<
      T,
      Prisma.ReflectionSession$personMentionsArgs<ExtArgs>
    >,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$PersonMentionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    | Null
  >
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(
    onfulfilled?:
      | ((value: T) => TResult1 | PromiseLike<TResult1>)
      | undefined
      | null,
    onrejected?:
      | ((reason: any) => TResult2 | PromiseLike<TResult2>)
      | undefined
      | null,
  ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(
    onrejected?:
      | ((reason: any) => TResult | PromiseLike<TResult>)
      | undefined
      | null,
  ): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(
    onfinally?: (() => void) | undefined | null,
  ): runtime.Types.Utils.JsPromise<T>
}

/**
 * Fields of the ReflectionSession model
 */
export interface ReflectionSessionFieldRefs {
  readonly id: Prisma.FieldRef<'ReflectionSession', 'String'>
  readonly userId: Prisma.FieldRef<'ReflectionSession', 'String'>
  readonly date: Prisma.FieldRef<'ReflectionSession', 'DateTime'>
  readonly status: Prisma.FieldRef<'ReflectionSession', 'String'>
  readonly recordingAttempt: Prisma.FieldRef<'ReflectionSession', 'Int'>
  readonly totalUserSpeakingTime: Prisma.FieldRef<'ReflectionSession', 'Int'>
  readonly maxDuration: Prisma.FieldRef<'ReflectionSession', 'Int'>
  readonly summaryText: Prisma.FieldRef<'ReflectionSession', 'String'>
  readonly pausedAt: Prisma.FieldRef<'ReflectionSession', 'DateTime'>
  readonly completedAt: Prisma.FieldRef<'ReflectionSession', 'DateTime'>
  readonly createdAt: Prisma.FieldRef<'ReflectionSession', 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<'ReflectionSession', 'DateTime'>
}

// Custom InputTypes
/**
 * ReflectionSession findUnique
 */
export type ReflectionSessionFindUniqueArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ReflectionSession
   */
  select?: Prisma.ReflectionSessionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ReflectionSession
   */
  omit?: Prisma.ReflectionSessionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReflectionSessionInclude<ExtArgs> | null
  /**
   * Filter, which ReflectionSession to fetch.
   */
  where: Prisma.ReflectionSessionWhereUniqueInput
}

/**
 * ReflectionSession findUniqueOrThrow
 */
export type ReflectionSessionFindUniqueOrThrowArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ReflectionSession
   */
  select?: Prisma.ReflectionSessionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ReflectionSession
   */
  omit?: Prisma.ReflectionSessionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReflectionSessionInclude<ExtArgs> | null
  /**
   * Filter, which ReflectionSession to fetch.
   */
  where: Prisma.ReflectionSessionWhereUniqueInput
}

/**
 * ReflectionSession findFirst
 */
export type ReflectionSessionFindFirstArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ReflectionSession
   */
  select?: Prisma.ReflectionSessionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ReflectionSession
   */
  omit?: Prisma.ReflectionSessionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReflectionSessionInclude<ExtArgs> | null
  /**
   * Filter, which ReflectionSession to fetch.
   */
  where?: Prisma.ReflectionSessionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of ReflectionSessions to fetch.
   */
  orderBy?:
    | Prisma.ReflectionSessionOrderByWithRelationInput
    | Prisma.ReflectionSessionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for ReflectionSessions.
   */
  cursor?: Prisma.ReflectionSessionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` ReflectionSessions from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` ReflectionSessions.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of ReflectionSessions.
   */
  distinct?:
    | Prisma.ReflectionSessionScalarFieldEnum
    | Prisma.ReflectionSessionScalarFieldEnum[]
}

/**
 * ReflectionSession findFirstOrThrow
 */
export type ReflectionSessionFindFirstOrThrowArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ReflectionSession
   */
  select?: Prisma.ReflectionSessionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ReflectionSession
   */
  omit?: Prisma.ReflectionSessionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReflectionSessionInclude<ExtArgs> | null
  /**
   * Filter, which ReflectionSession to fetch.
   */
  where?: Prisma.ReflectionSessionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of ReflectionSessions to fetch.
   */
  orderBy?:
    | Prisma.ReflectionSessionOrderByWithRelationInput
    | Prisma.ReflectionSessionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for ReflectionSessions.
   */
  cursor?: Prisma.ReflectionSessionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` ReflectionSessions from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` ReflectionSessions.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of ReflectionSessions.
   */
  distinct?:
    | Prisma.ReflectionSessionScalarFieldEnum
    | Prisma.ReflectionSessionScalarFieldEnum[]
}

/**
 * ReflectionSession findMany
 */
export type ReflectionSessionFindManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ReflectionSession
   */
  select?: Prisma.ReflectionSessionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ReflectionSession
   */
  omit?: Prisma.ReflectionSessionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReflectionSessionInclude<ExtArgs> | null
  /**
   * Filter, which ReflectionSessions to fetch.
   */
  where?: Prisma.ReflectionSessionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of ReflectionSessions to fetch.
   */
  orderBy?:
    | Prisma.ReflectionSessionOrderByWithRelationInput
    | Prisma.ReflectionSessionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for listing ReflectionSessions.
   */
  cursor?: Prisma.ReflectionSessionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` ReflectionSessions from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` ReflectionSessions.
   */
  skip?: number
  distinct?:
    | Prisma.ReflectionSessionScalarFieldEnum
    | Prisma.ReflectionSessionScalarFieldEnum[]
}

/**
 * ReflectionSession create
 */
export type ReflectionSessionCreateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ReflectionSession
   */
  select?: Prisma.ReflectionSessionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ReflectionSession
   */
  omit?: Prisma.ReflectionSessionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReflectionSessionInclude<ExtArgs> | null
  /**
   * The data needed to create a ReflectionSession.
   */
  data: Prisma.XOR<
    Prisma.ReflectionSessionCreateInput,
    Prisma.ReflectionSessionUncheckedCreateInput
  >
}

/**
 * ReflectionSession createMany
 */
export type ReflectionSessionCreateManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to create many ReflectionSessions.
   */
  data:
    | Prisma.ReflectionSessionCreateManyInput
    | Prisma.ReflectionSessionCreateManyInput[]
}

/**
 * ReflectionSession createManyAndReturn
 */
export type ReflectionSessionCreateManyAndReturnArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ReflectionSession
   */
  select?: Prisma.ReflectionSessionSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ReflectionSession
   */
  omit?: Prisma.ReflectionSessionOmit<ExtArgs> | null
  /**
   * The data used to create many ReflectionSessions.
   */
  data:
    | Prisma.ReflectionSessionCreateManyInput
    | Prisma.ReflectionSessionCreateManyInput[]
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReflectionSessionIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * ReflectionSession update
 */
export type ReflectionSessionUpdateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ReflectionSession
   */
  select?: Prisma.ReflectionSessionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ReflectionSession
   */
  omit?: Prisma.ReflectionSessionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReflectionSessionInclude<ExtArgs> | null
  /**
   * The data needed to update a ReflectionSession.
   */
  data: Prisma.XOR<
    Prisma.ReflectionSessionUpdateInput,
    Prisma.ReflectionSessionUncheckedUpdateInput
  >
  /**
   * Choose, which ReflectionSession to update.
   */
  where: Prisma.ReflectionSessionWhereUniqueInput
}

/**
 * ReflectionSession updateMany
 */
export type ReflectionSessionUpdateManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to update ReflectionSessions.
   */
  data: Prisma.XOR<
    Prisma.ReflectionSessionUpdateManyMutationInput,
    Prisma.ReflectionSessionUncheckedUpdateManyInput
  >
  /**
   * Filter which ReflectionSessions to update
   */
  where?: Prisma.ReflectionSessionWhereInput
  /**
   * Limit how many ReflectionSessions to update.
   */
  limit?: number
}

/**
 * ReflectionSession updateManyAndReturn
 */
export type ReflectionSessionUpdateManyAndReturnArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ReflectionSession
   */
  select?: Prisma.ReflectionSessionSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ReflectionSession
   */
  omit?: Prisma.ReflectionSessionOmit<ExtArgs> | null
  /**
   * The data used to update ReflectionSessions.
   */
  data: Prisma.XOR<
    Prisma.ReflectionSessionUpdateManyMutationInput,
    Prisma.ReflectionSessionUncheckedUpdateManyInput
  >
  /**
   * Filter which ReflectionSessions to update
   */
  where?: Prisma.ReflectionSessionWhereInput
  /**
   * Limit how many ReflectionSessions to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReflectionSessionIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * ReflectionSession upsert
 */
export type ReflectionSessionUpsertArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ReflectionSession
   */
  select?: Prisma.ReflectionSessionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ReflectionSession
   */
  omit?: Prisma.ReflectionSessionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReflectionSessionInclude<ExtArgs> | null
  /**
   * The filter to search for the ReflectionSession to update in case it exists.
   */
  where: Prisma.ReflectionSessionWhereUniqueInput
  /**
   * In case the ReflectionSession found by the `where` argument doesn't exist, create a new ReflectionSession with this data.
   */
  create: Prisma.XOR<
    Prisma.ReflectionSessionCreateInput,
    Prisma.ReflectionSessionUncheckedCreateInput
  >
  /**
   * In case the ReflectionSession was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<
    Prisma.ReflectionSessionUpdateInput,
    Prisma.ReflectionSessionUncheckedUpdateInput
  >
}

/**
 * ReflectionSession delete
 */
export type ReflectionSessionDeleteArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ReflectionSession
   */
  select?: Prisma.ReflectionSessionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ReflectionSession
   */
  omit?: Prisma.ReflectionSessionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReflectionSessionInclude<ExtArgs> | null
  /**
   * Filter which ReflectionSession to delete.
   */
  where: Prisma.ReflectionSessionWhereUniqueInput
}

/**
 * ReflectionSession deleteMany
 */
export type ReflectionSessionDeleteManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which ReflectionSessions to delete
   */
  where?: Prisma.ReflectionSessionWhereInput
  /**
   * Limit how many ReflectionSessions to delete.
   */
  limit?: number
}

/**
 * ReflectionSession.turns
 */
export type ReflectionSession$turnsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ReflectionTurn
   */
  select?: Prisma.ReflectionTurnSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ReflectionTurn
   */
  omit?: Prisma.ReflectionTurnOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReflectionTurnInclude<ExtArgs> | null
  where?: Prisma.ReflectionTurnWhereInput
  orderBy?:
    | Prisma.ReflectionTurnOrderByWithRelationInput
    | Prisma.ReflectionTurnOrderByWithRelationInput[]
  cursor?: Prisma.ReflectionTurnWhereUniqueInput
  take?: number
  skip?: number
  distinct?:
    | Prisma.ReflectionTurnScalarFieldEnum
    | Prisma.ReflectionTurnScalarFieldEnum[]
}

/**
 * ReflectionSession.mood
 */
export type ReflectionSession$moodArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ReflectionMood
   */
  select?: Prisma.ReflectionMoodSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ReflectionMood
   */
  omit?: Prisma.ReflectionMoodOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReflectionMoodInclude<ExtArgs> | null
  where?: Prisma.ReflectionMoodWhereInput
}

/**
 * ReflectionSession.topics
 */
export type ReflectionSession$topicsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ReflectionTopic
   */
  select?: Prisma.ReflectionTopicSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ReflectionTopic
   */
  omit?: Prisma.ReflectionTopicOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReflectionTopicInclude<ExtArgs> | null
  where?: Prisma.ReflectionTopicWhereInput
  orderBy?:
    | Prisma.ReflectionTopicOrderByWithRelationInput
    | Prisma.ReflectionTopicOrderByWithRelationInput[]
  cursor?: Prisma.ReflectionTopicWhereUniqueInput
  take?: number
  skip?: number
  distinct?:
    | Prisma.ReflectionTopicScalarFieldEnum
    | Prisma.ReflectionTopicScalarFieldEnum[]
}

/**
 * ReflectionSession.insights
 */
export type ReflectionSession$insightsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ReflectionInsight
   */
  select?: Prisma.ReflectionInsightSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ReflectionInsight
   */
  omit?: Prisma.ReflectionInsightOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReflectionInsightInclude<ExtArgs> | null
  where?: Prisma.ReflectionInsightWhereInput
  orderBy?:
    | Prisma.ReflectionInsightOrderByWithRelationInput
    | Prisma.ReflectionInsightOrderByWithRelationInput[]
  cursor?: Prisma.ReflectionInsightWhereUniqueInput
  take?: number
  skip?: number
  distinct?:
    | Prisma.ReflectionInsightScalarFieldEnum
    | Prisma.ReflectionInsightScalarFieldEnum[]
}

/**
 * ReflectionSession.personMentions
 */
export type ReflectionSession$personMentionsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the PersonMention
   */
  select?: Prisma.PersonMentionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PersonMention
   */
  omit?: Prisma.PersonMentionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PersonMentionInclude<ExtArgs> | null
  where?: Prisma.PersonMentionWhereInput
  orderBy?:
    | Prisma.PersonMentionOrderByWithRelationInput
    | Prisma.PersonMentionOrderByWithRelationInput[]
  cursor?: Prisma.PersonMentionWhereUniqueInput
  take?: number
  skip?: number
  distinct?:
    | Prisma.PersonMentionScalarFieldEnum
    | Prisma.PersonMentionScalarFieldEnum[]
}

/**
 * ReflectionSession without action
 */
export type ReflectionSessionDefaultArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ReflectionSession
   */
  select?: Prisma.ReflectionSessionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ReflectionSession
   */
  omit?: Prisma.ReflectionSessionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReflectionSessionInclude<ExtArgs> | null
}
